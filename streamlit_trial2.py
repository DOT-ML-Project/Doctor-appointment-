# -*- coding: utf-8 -*-
"""streamlit_trial2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gIyU1era_YZWtv4a61HQA7CBFQulqL0R
"""

import streamlit as st
import hashlib
import datetime

# Define the Block class
class Block:
    def __init__(self, index, timestamp, data, previous_hash):
        self.index = index
        self.timestamp = timestamp
        self.data = data
        self.previous_hash = previous_hash
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        block_string = f"{self.index}{self.timestamp}{self.data}{self.previous_hash}"
        return hashlib.sha256(block_string.encode()).hexdigest()

# Initialize blockchain with the genesis block
def create_genesis_block():
    return Block(0, str(datetime.datetime.now()), "Genesis Block", "0")

if 'blockchain' not in st.session_state:
    st.session_state.blockchain = [create_genesis_block()]

# Function to add a block to the blockchain
def add_block(data):
    last_block = st.session_state.blockchain[-1]
    new_block = Block(
        index=last_block.index + 1,
        timestamp=str(datetime.datetime.now()),
        data=data,
        previous_hash=last_block.hash
    )
    st.session_state.blockchain.append(new_block)

# Streamlit UI
st.title("üîê Doctor Appointment Blockchain Booking")

with st.form("appointment_form"):
    patient_name = st.text_input("Patient Name")
    doctor_name = st.text_input("Doctor Name")
    appointment_time = st.datetime_input("Appointment Time")
    submitted = st.form_submit_button("Book Appointment")

if submitted:
    appointment_data = {
        "patient": patient_name,
        "doctor": doctor_name,
        "time": str(appointment_time)
    }
    add_block(str(appointment_data))
    st.success("Appointment booked and added to blockchain!")

st.subheader("üìÇ Current Blockchain:")
for block in st.session_state.blockchain:
    st.write(f"**Block {block.index}:**")
    st.json({
        "Timestamp": block.timestamp,
        "Data": block.data,
        "Previous Hash": block.previous_hash,
        "Hash": block.hash
    })